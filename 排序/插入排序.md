- 最简单的排序
#### 直接插入排序
```C
void insertSort(int nums[],int size){
	for(int i=1;i<size;i++){
		int base=nums[i];
		int j=i-1;
		while(j>=0&&nums[j]>base){
			nums[j+1]=nums[j];
			j--;
		}
		nums[j+1]=base;
	}
}
```
- 时间复杂度：O($n^{2}$)
- 空间复杂度有：O(1)
- 稳定性：稳定

#### 折半插入排序：

#### 2-路插入排序：

#### 表插入排序：

#### 希尔排序：
- 缩小增量排序
```C
void shellSort(int arr[],int n){
	for(int gap=n/2;gap>0;gap=gap/2){
		for(int i=gap;i<n;i++){
			int temp=arr[i];
			for(int j=i;j>=gap&&arr[j-gap];j-=gap){
				arr[j]=arr[j-gap];
			}
		}
	}
}
```
示例:
假设我们有一个数组 `[8, 5, 3, 7, 6, 2, 4, 1]`，我们将使用希尔排序进行排序。
1. **初始数组**：`[8, 5, 3, 7, 6, 2, 4, 1]`
2. **选择增量**：假设初始增量为4
3. **分组**：
    - 第一组：`[8, 6]`
    - 第二组：`[5, 2]`
    - 第三组：`[3, 4]`
    - 第四组：`[7, 1]`
4. **排序每组**：
    - 第一组排序后：`[6, 8]`
    - 第二组排序后：`[2, 5]`
    - 第三组排序后：`[3, 4]`
    - 第四组排序后：`[1, 7]`
5. **合并**：得到新数组 `[6, 2, 3, 1, 8, 5, 4, 7]`
6. **减少增量**：下一个增量为2，重复上述步骤。
7. **最终增量为1**：对整个数组进行最后的插入排序，得到有序数组。
时间复杂度:
- 最坏情况：O(n^2)
- 平均情况：O(n^(3/2))
- 最好情况：O(n log n)
 空间复杂度有：O(1)
 稳定性：不稳定